Mise en production
==================

flux de travail
---------------
#. Modification du code source
#. Commit des changements vers le repertoire distant
#. Déclanchement automatique de la routine CircleCI
#. Lancement de la suite de test
#. Lancement du test de couverture du code
#. Lancement du test de Linting
#. Les résultats du test de Linting et de courverture ne sont pas blocant
#. Si la suite de test se termine avec succés, circleCI à la création du conteneur Docker
#. Aprés avoir reçu un tag unique, l'image est envoyé sur dockerHub
#. La réception d'une nouvelle image sur dockerHub déclanche la routina par Render
#. Render, au signal d'une nouvelle image, va récupérer celle-ci.
#. Lancer une série de commande pour lancer le conteneur, distribuer les fichiers statiques et lancer le serveur Django

Gestion du deploiement
----------------------

Configuration
^^^^^^^^^^^^^
* selectionner une image docker depuis circleCI ``
    | docker:
    |  - image: cimg/python:3.10
* charger les variables d'environnement. Dans notre cas, on défini la variable ALLOWED_HOSTS pour django
    | environment:
    |  - ALLOWED_HOSTS: localhost
* On viens définir ensuite les étapes de notre taches
    * `- checkout` : récupération du code depuis github
    * `- restore_cache: key: deps1-{{ .Branch }}-{{ checksum "requirements.txt" }}` circleCI va chercher à restorer un cache ayant un tag unique composé du nom de la branche et du checksum basé sur requirements.txt
    *  La suite des instructions permet de créer un environment virtuel, son exécecution et l'installation des librairies. Si un fichier de cache existe, les instructions seront évalué mais les actions sont déjà réalisées.
        | python3 -m venv venv
        | . venv/bin/activate
        | pip install -U pip setuptools
        | pip install -r requirements.txt
    * on créer un cache pour faciliter la prochaine exécution.
        | key: deps1-{{ .Branch }}-{{ checksum "requirements.txt" }}
        |  paths:
        |   - "venv"
    * Enfin on excécute la commande d'interêt. Dans ce cas, on active l'environment virtuel et on exécute le module pytest
        | name: Running tests
        | command: |
        |   . venv/bin/activate
        |   python3 -m pytest

Procédure
^^^^^^^^^

Gestion de l'application
------------------------

